#!/bin/sh
#
# Set up a home directory on a Unix system.

set -u

dotfiledirs="dotfiles"

# requires running form the root of the dotfiles directory
rootdir=$(cd "$(dirname ./install)" && pwd)
if [ "${rootdir}" != "${PWD}" ]; then
    echo "must be run from the root of the dotfiles directory"
    exit 1
fi

# requires HOME.
if [ -z "${HOME}" ]; then
    echo "HOME is not set, aborting"
    exit 1
fi

# ask user for the type of machine
echo "Enter machine type {linux, osx, windows}: \c"
read -r machine
if [ ! -z "${machine}" ]; then
    if [ "${machine}" = linux ]; then
        echo "Installing for Linux"
    elif [ "${machine}" = osx ]; then
        echo "Installing for OS X"
    elif [ "${machine}" = windows ]; then
        echo "Installing for Windows"
    else
        echo "error: unknown machine ${machine}, aborting"
        exit 1
    fi
else
    echo "error: machine must be set, aborting"
    exit 1
fi

# create ~/opt/local if desired
if [ ! -d "${HOME}"/opt ] || [ ! -d "${HOME}"/opt/local ]; then
    echo "create ~/opt/local? (y/n)?: \c"
    read -r yn
    if [ "${yn}" = "y" ]; then
        mkdir -p "${HOME}"/opt/local/bin
        mkdir -p "${HOME}"/opt/local/include
        mkdir -p "${HOME}"/opt/local/lib
        mkdir -p "${HOME}"/opt/local/man
        mkdir -p "${HOME}"/opt/local/mnt
        mkdir -p "${HOME}"/opt/local/share
        mkdir -p "${HOME}"/opt/local/src

        # populate ~/opt/local if it exists and desired
        echo "nothing installed to ~/opt/local by default"
    fi
fi

# set up machine-specific ~/.bashrc
if [ ! -e "${HOME}"/.bashrc.local ]; then
    echo "~/.bashrc.local is used for machine-specific bash settings."
    touch "${HOME}"/.bashrc.local
fi

# configure git
git=$(which git 2> /dev/null)
if [ ! -z "${git}" ] && [ -x "${git}" ]; then
    # set up machine-specific ~/.gitconfig
    if [ ! -e "${HOME}"/.gitconfig.machine ]; then
        echo "~/.gitconfig.machine is used for machine-specific settings to .gitconfig."
        touch "${HOME}"/.gitconfig.machine
    fi

    # set up a credential helper
    if [ "${machine}" = linux ]; then
        git config -f "${HOME}"/.gitconfig.machine credential.helper 'cache --timeout 3600'
    elif [ "${machine}" = osx ]; then
        git config -f "${HOME}"/.gitconfig.machine credential.helper 'osxkeychain'
    elif [ "${machine}" = windows ]; then
        git config -f "${HOME}"/.gitconfig.machine credential.helper 'winstore'
    else
        echo "error: unknown machine ${machine}."
        exit 1
    fi

    # set up user-specific ~/.gitconfig
    if [ ! -e "${HOME}"/.gitconfig.user ]; then
        echo "~/.gitconfig.user is used for user-specific settings to .gitconfig."
        touch "${HOME}"/.gitconfig.user
    fi

    # configure user name and email for git
    git_name=
    git_email=

    # if not set, suggest user name and email from global git config
    if [ -z "${git_name}" ] && [ -z "${git_email}" ]; then
        proposed_name=$(${git} config --global user.name)
        proposed_email=$(${git} config --global user.email)

        if [ ! -z "${proposed_name}" ] || [ ! -z "${proposed_email}" ]; then
            echo "use current global user information '${proposed_name} <${proposed_email}>' for git (y/n): \c"
            read -r yn
            if [ "${yn}" = "y" ]; then
                git_name=${proposed_name}
                git_email=${proposed_email}
            fi
        fi
    fi

    # if not set, suggest user name and email from user-specific git confg
    if [ -z "${git_name}" ] && [ -z "${git_email}" ]; then
        proposed_name=$(${git} config -f "${HOME}"/.gitconfig.user user.name)
        proposed_email=$(${git} config -f "${HOME}"/.gitconfig.user user.email)

        if [ ! -z "${proposed_name}" ] && [ ! -z "${proposed_email}" ]; then
            echo "use current user-specific user information '${proposed_name} <${proposed_email}>' for git (y/n): \c"
            read -r yn
            if [ "${yn}" = "y" ]; then
                git_name=${proposed_name}
                git_email=${proposed_email}
            fi
        fi
    fi

    # if not set, ask the user for name
    if [ -z "${git_name}" ]; then
        echo "Enter git user name: \c"
        read -r git_name
    fi
    # if not set, ask the user for email
    if [ -z "${git_email}" ]; then
        echo "Enter git user email: \c"
        read -r git_email
    fi

    # set the user-specific git config and clear the global git config
    if [ ! -z "${git_name}" ] || [ ! -z "${git_email}" ]; then
        echo "setting user-specific user information to '${git_name} <${git_email}>' for git (y/n): \c"
        read -r yn
        if [ "${yn}" = "y" ]; then
            # set user name/email in user-specific config
            ${git} config -f "${HOME}"/.gitconfig.user user.name "${git_name}"
            ${git} config -f "${HOME}"/.gitconfig.user user.email "${git_email}"

            # if present, clear user in global git config
            if [ ! -z "$(${git} config --global user.name)" ] || [ ! -z "$(${git} config --global user.email)" ]; then
                ${git} config --global --remove-section user
            fi
        fi
    fi
fi

# configure mercurial
hg=$(which hg 2> /dev/null)
if [ ! -z "${hg}" ] && [ -x "${hg}" ]; then
    # set up machine-specific ~/.hgrc
    if [ ! -e "${HOME}"/.hgrc.machine ]; then
        echo "~/.hgrc.machine is used for machine-specific settings to .hgrc."
        touch "${HOME}"/.hgrc.machine
    fi

    # set up user-specific ~/.hgrc
    if [ ! -e "${HOME}"/.hgrc.user ]; then
        echo "~/.hgrc.user is used for user-specific settings to .hgrc."
        touch "${HOME}"/.hgrc.user
    fi

    #! @todo use hg to set up user
fi

# requires stow
stow=$(which stow 2> /dev/null)
if [ -z "${stow}" ] || [ ! -x "${stow}" ]; then
    echo "'stow' is not available"
    exit 1
fi

# attempt to stow the dotfiles directory, clean up if fails.
if ! ${stow} --target="${HOME}" dotfiles ; then
    # requires diff
    diff=$(which diff 2> /dev/null)
    if [ -z "${diff}" ] || [ ! -x "${diff}" ]; then
        echo "'diff' is not available"
        exit 1
    fi

    # allow user to clean up existing files
    for d in ${dotfiledirs} ; do
        for f in $(find ${d} -type f) ; do
            home_f="${HOME}"/$(basename "${f}")
            if [ -e "${home_f}" ]; then
                if [ "${f}" != "${home_f}" ]; then
                    if ${diff} "${f}" "${home_f}" ; then
                        echo "${f} is identical to ${home_f}.  Overwrite (y/n)?: \c"
                        read -r yn
                        if [ "${yn}" = "y" ]; then
                            rm -i "${home_f}"
                        fi
                    else
                        echo "${f} is different than ${home_f}.  Overwrite anyway (y/n)?: \c"
                        read -r yn
                        if [ "${yn}" = "y" ]; then
                            rm -i "${home_f}"
                        fi
                    fi
                fi
            fi
        done
    done

    if ! ${stow} --target="${HOME}" dotfiles ; then
        echo "error: some targets could not be linked to home directory."
        exit 1
    fi
fi

# ask to install any services
echo "Install services (launchd or systemd)? (y/n)?: \c"
read -r yn
if [ "${yn}" = "y" ]; then
    if [ "${machine}" = linux ]; then
        # @todo untested
        for f in $(pwd)/services/systemd/*.plist; do
            ln -i -v -s "${f}" "${HOME}"/.config/systemd/user

            b=$(basename "${f}" .service)
            systemctl --user enable "${b}"
        done
    elif [ "${machine}" = osx ]; then
        for f in $(pwd)/services/launchd/*.plist; do
            ln -i -v -s "${f}" "${HOME}"/Library/LaunchAgents

            b=$(basename "${f}" .plist)
            l=user/"$(id -u)"/"${b}"
            launchctl enable "${l}"
        done
    elif [ "${machine}" = windows ]; then
        echo "error: services install not implemented yet for windows"
        exit 1
    else
        echo "error: unknown machine ${machine}."
        exit 1
    fi
fi

# configure emacs
emacs=$(which emacs 2> /dev/null)
if [ ! -z "${emacs}" ] && [ -x "${emacs}" ]; then
    # set up machine-specific ~/.emacs
    if [ ! -e "${HOME}"/.emacs.machine.el ]; then
        echo "~/.emacs.machine is used for machine-specific settings to .emacs."
        touch "${HOME}"/.emacs.machine.el
        echo ";;; package --- Machine-specific Emacs initialization." >> "${HOME}"/.emacs.machine.el
        echo "" >> "${HOME}"/.emacs.machine.el
        echo ";;; Commentary:" >> "${HOME}"/.emacs.machine.el
        echo "" >> "${HOME}"/.emacs.machine.el
        echo ";;; Code:" >> "${HOME}"/.emacs.machine.el
        echo "" >> "${HOME}"/.emacs.machine.el
        echo "(provide '.emacs.machine)" >> "${HOME}"/.emacs.machine.el
        echo "" >> "${HOME}"/.emacs.machine.el
        echo ";;; .emacs.machine.el ends here" >> "${HOME}"/.emacs.machine.el
    fi

    # ensure that emacs knows a good host name
    emacs_hostname=

    # if not set, suggest the global system name for emacs
    if [ -z "${emacs_hostname}" ]; then
        proposed_hostname=$(${emacs} --batch --no-init-file --eval "(princ system-name)")

        if [ ! -z "${proposed_hostname}" ]; then
            echo "use current emacs system-name '${proposed_hostname}' for emacs (y/n): \c"
            read -r yn
            if [ "${yn}" = "y" ]; then
                emacs_hostname=${proposed_hostname}
            fi
        fi
    fi

    # if not set, suggest the user-specific system name for emacs
    if [ -z "${emacs_hostname}" ]; then
        proposed_hostname=$(${emacs} --batch --no-init-file --load "${HOME}"/.emacs.user.el --eval "(princ system-name)")

        if [ ! -z "${proposed_hostname}" ]; then
            echo "use user-specific emacs system-name '${proposed_hostname}' for emacs (y/n): \c"
            read -r yn
            if [ "${yn}" = "y" ]; then
                emacs_hostname=${proposed_hostname}
            fi
        fi
    fi

    # if not set, suggest the hostname of the computer for emacs
    if [ -z "${emacs_hostname}" ]; then
        proposed_hostname=$(hostname)

        if [ ! -z "${proposed_hostname}" ]; then
            echo "use hostname '${proposed_hostname}' for emacs (y/n): \c"
            read -r yn
            if [ "${yn}" = "y" ]; then
                emacs_hostname=${proposed_hostname}
            fi
        fi
    fi

    # if not set, ask the user for the hostname
    if [ -z "${emacs_hostname}" ]; then
        echo "Enter system-name for emacs: \c"
        read -r emacs_hostname
    fi

    # set the system-name for emacs
    # @todo nice to edit the lisp s-expressions directly
    if [ ! -z "${emacs_hostname}" ]; then
        echo "use system-name '${emacs_hostname}' for emacs (y/n) \c"
        read -r yn
        if [ "${yn}" = "y" ]; then
            echo "Add the following to ~/.emacs.machine.el"
            echo "   (setq system-name \"${emacs_hostname}\")"
        fi
    fi

    # set up user-specific ~/.emacs
    if [ ! -e "${HOME}"/.emacs.user.el ]; then
        echo "~/.emacs.user is used for user-specific settings to .emacs."
        touch "${HOME}"/.emacs.user.el
        echo ";;; package --- User-specific Emacs initialization." >> "${HOME}"/.emacs.user.el
        echo "" >> "${HOME}"/.emacs.user.el
        echo ";;; Commentary:" >> "${HOME}"/.emacs.user.el
        echo "" >> "${HOME}"/.emacs.user.el
        echo ";;; Code:" >> "${HOME}"/.emacs.user.el
        echo "" >> "${HOME}"/.emacs.user.el
        echo "(provide '.emacs.user)" >> "${HOME}"/.emacs.user.el
        echo "" >> "${HOME}"/.emacs.user.el
        echo ";;; .emacs.user.el ends here" >> "${HOME}"/.emacs.user.el
    fi

    emacs_name=
    emacs_email=

    # if not set, suggest the global user's full name for emacs
    if [ -z "${emacs_name}" ]; then
        proposed_name=$(${emacs} --batch --no-init-file --eval "(princ user-full-name)")

        if [ ! -z "${proposed_name}" ]; then
            echo "use current global user's full name '${proposed_name}' for emacs (y/n): \c"
            read -r yn
            if [ "${yn}" = "y" ]; then
                emacs_name=${proposed_name}
            fi
        fi
    fi

    # if not set, suggest the user-specific user's full name for emacs
    if [ -z "${emacs_name}" ]; then
        proposed_name=$(${emacs} --batch --no-init-file --load "${HOME}"/.emacs.user.el --eval "(princ user-full-name)")

        if [ ! -z "${proposed_name}" ]; then
            echo "use current user-specific user's full name '${proposed_name}' for emacs (y/n): \c"
            read -r yn
            if [ "${yn}" = "y" ]; then
                emacs_name=${proposed_name}
            fi
        fi
    fi

    # if not set, ask user for the user's full name for emacs
    if [ -z "${emacs_name}" ]; then
        echo "Enter the user's full name for emacs: \c"
        read -r emacs_name
    fi

    # if not set, suggest the global user's email for emacs
    if [ -z "${emacs_email}" ]; then
        proposed_email=$(${emacs} --batch --no-init-file --eval "(princ user-mail-address)")

        if [ ! -z "${proposed_email}" ]; then
            echo "use current global user's email '${proposed_email}' for emacs (y/n): \c"
            read -r yn
            if [ "${yn}" = "y" ]; then
                emacs_email=${proposed_email}
            fi
        fi
    fi

    # if not set, suggest the user-specific user's email for emacs
    if [ -z "${emacs_email}" ]; then
        proposed_email=$(${emacs} --batch --no-init-file --load "${HOME}"/.emacs.user.el --eval "(princ user-mail-address)")

        if [ ! -z "${proposed_email}" ]; then
            echo "use current user-specific user's email '${proposed_email}' for emacs (y/n): \c"
            read -r yn
            if [ "${yn}" = "y" ]; then
                emacs_email=${proposed_email}
            fi
        fi
    fi

    # if not set, ask user for the user's email for emacs
    if [ -z "${emacs_email}" ]; then
        echo "Enter the user's email for emacs: \c"
        read -r emacs_email
    fi

    # set the user's full name and email for emacs
    # @todo nice to edit the lisp s-expressions directly
    if [ ! -z "${emacs_name}" ]; then
        echo "use user's full name '${emacs_name}' for emacs (y/n): \c"
        read -r yn
        if [ "${yn}" = "y" ]; then
            echo "Add the following to ~/.emacs.user.el"
            echo "   (setq user-full-name \"${emacs_name}\")"
        fi
    fi
    if [ ! -z "${emacs_email}" ]; then
        echo "use user's email '${emacs_email}' for emacs (y/n): \c"
        read -r yn
        if [ "${yn}" = "y" ]; then
            echo "Add the following to ~/.emacs.user.el"
            echo "   (setq user-mail-address \"${emacs_email}\")"
        fi
    fi
fi

# ask to install python packages
echo "Install Python packages? (y/n)?: \c"
read -r yn
if [ "${yn}" = "y" ]; then
    if ! ./install_python_packages ; then
        echo "warning: failed to install Python packages."
    fi
fi

# ask to install ruby packages
echo "Install Ruby packages? (y/n)?: \c"
read -r yn
if [ "${yn}" = "y" ]; then
    if ! ./install_ruby_packages ; then
        echo "warning: failed to install Ruby packages."
    fi
fi

# ask to install node packages
echo "Install Node packages? (y/n)?: \c"
read -r yn
if [ "${yn}" = "y" ]; then
    if ! ./install_node_packages ; then
        echo "warning: failed to install Node.js packages."
    fi
fi

# ask to install go packages
echo "Install Go packages? (y/n)?: \c"
read -r yn
if [ "${yn}" = "y" ]; then
    if ! ./install_go_packages ; then
        echo "warning: failed to install Go packages."
    fi
fi
